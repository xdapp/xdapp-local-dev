#!/usr/bin/env node
const program     = require('commander');
const path        = require('path');
const fs          = require('fs');
const crypto      = require('crypto');
const YAML        = require('yaml');
const UglifyJS    = require("uglify-es");
const sass        = require('node-sass');
const compilerVue = require('./compiler-vue');

// 根目录
const BASE_DIR  = path.resolve(__dirname + '/../') + '/';
const SRC_DIR   = `${BASE_DIR}src/`;
const VERSION   = 'apps';
const OUT_DIR   = `${BASE_DIR}webroot/${VERSION}/`;
const HASH_FILE = `${OUT_DIR}assets-hash.json`;
const projectFile = BASE_DIR + 'projects.json';

let assetsHash = fs.existsSync(HASH_FILE) ? JSON.parse(fs.readFileSync(HASH_FILE)) : {};
let assetsHashTime = new Date().getTime();
let isDevelop  = false;
let isCompress = true;

if (process.argv[1] !== __filename) {
    // 导出方法
    module.exports = {
        buildFile,
        reBuild: function (opt = {}) {
            let from = SRC_DIR;
            let to   = OUT_DIR;
            if (!opt.onlyMissFile) {
                if (fs.existsSync(to)) {
                    console.log(`    \x1b[33mclean: ${to}\x1b[0m`);
                    cleanDir(to);
                }
                assetsHash = {};
            }

            let tick = null;
            opt.done = (result) => {
                if (isAssetFile(result.out)) {
                    setAssetFileHash(result.out, result.hash || md5(result.content), true);
                    if (tick) {
                        clearTimeout(tick);
                        tick = null;
                    }
                    tick = setTimeout(() => {
                        tick = null;
                        saveAssetHashFile();
                    }, 200);
                }
            };
            buildDir(from, to, opt);
        },
        watchProject,
        checkDirDiff,
        assetsForUpdate,
        assetsForDownload,
        assetsForDelete,
        setDevelop: (status) => {
            isDevelop = status;
        },
        setCompress: (status) => {
            isCompress = status;
        },
        getAssetsHashFile() {
            return HASH_FILE;
        },
        isAssetFile: isAssetFile,
        getAssetVersion: () => {
            return VERSION;
        },
        getAssetsHash: () => {
            return assetsHash;
        },
        getAssetsHashTime: () => {
            return assetsHashTime;
        },
    };
}
else {
    // 命令行执行
    const myName = __filename.split(path.sep).pop();
    program
        .version('1.1')
        .usage('watch|build|deploy [options]')
        .option('--dev', '研发模式')
        .option('--nomap', '不输出map')
        .option('--nocompress', '关闭压缩')
        .option('-c, --config <string>', 'down|deploy|diff 可用, 配置文件，默认根目录的 assets-deploy.json 文件')
        .option('--clean', 'build|down|deploy 可用, 清除目录下文件多余文件');

    program
    .command('update')
    .description('更新当前本地开发工具')
    .action(() => {
        const localUp = require('./update-local-dev.js');
        localUp.update();
    });

    program
        .command('build [dir]')
        .description(       '生成指定文件'
        +`\n                       只生成指定文件: ${myName} build js/test.js`
        +`\n                       生成指定文件夹: ${myName} build [js|css|page|i18n]`
        +`\n                         例: ${myName} build js`
        +`\n                         例: ${myName} build css/test/`
        )
        .action((dir) => {
            isDevelop = !!program.dev;
            isCompress = !program.nocompress;
            if (dir)dir = dir.trim().replace(/[\/|\\]+$/, '').replace(/^[\/|\\]+/, '');
            let from = SRC_DIR + (dir ? dir : '');
            let to   = OUT_DIR + (dir ? dir : '');
            if (!fs.existsSync(from)) {
                console.log('指定的文件或目录不存在: ' + from);
                return;
            }
            let isDir;
            if (fs.lstatSync(from).isDirectory()) {
                if (dir) {
                    from += '/';
                    to += '/';
                }
                isDir = true;
            }
            else {
                isDir = false;
            }

            const opt = {
                compress: isCompress,
                dev : isDevelop,
                noMap : !!program.nomap,
            };

            if (isDir) {
                console.log('now loading files...');
                if (program.clean) {
                    // 清理文件
                    if (fs.existsSync(to)) {
                        console.log(`    \x1b[33mclean: ${to}\x1b[0m`);
                        cleanDir(to);
                    }
                    if (!dir) {
                        // 清空hash
                        assetsHash = {};
                    }
                    else {
                        // 移除当前目录下所有的hash
                        Object.keys(assetsHash).forEach((key) => {
                            if (key.substr(0, dir.length) === dir) {
                                delete assetsHash[key];
                            }
                        });
                    }
                }
                let tick = null;
                opt.done = (result) => {
                    if (isAssetFile(result.out)) {
                        setAssetFileHash(result.out, result.hash || md5(result.content), true);
                        if (tick) {
                            clearTimeout(tick);
                            tick = null;
                        }
                        tick = setTimeout(() => {
                            tick = null;
                            saveAssetHashFile();
                        }, 200);
                    }
                };
                buildDir(from, to, opt);
            }
            else {
                buildFile(from, getOutExtFileName(to), opt);
            }
        });
    program
        .command('watch')
        .description('监听项目文件修改')
        .action(() => {
            isDevelop = !!program.dev;
            isCompress = !program.nocompress;

            const opt = {
                compress: isCompress,
                noMap: !!program.nomap,
                dev : isDevelop,
            };
            watchProject(opt);
        });
    program
        .command('deploy [dir]')
        .description('部署文件到服务器'
            +'\n                       加 --clean 清除服务器目录下多余文件'
            +`\n                         例: ${myName} deploy`
            +`\n                         例: ${myName} deploy --dev`
            +`\n                         例: ${myName} deploy page/test.vue`
        )
        .action((dir) => {
            isDevelop = !!program.dev;
            isCompress = !program.nocompress;

            const opt = {
                compress: isCompress,
                noMap: !!program.nomap,
                dev : isDevelop,
                clean: program.clean
            };
            deployDir(dir, opt);
        });
    program
        .command('down [dir]')
        .description('下载远程文件到本地, 参数同deploy'
            +'\n                       加 --clean 清除本地目录下多余文件'
            +`\n                         例: ${myName} down`
        )
        .action((dir) => {
            isDevelop = !!program.dev;
            isCompress = !program.nocompress;

            const opt = {
                compress: isCompress,
                noMap: !!program.nomap,
                dev : isDevelop,
            };
            downloadDir(dir, opt);
        });
    program
        .command('diff [dir]')
        .description('检查本地和远程差异的文件, 参数同deploy\n')
        .action((dir) => {
            isDevelop = !!program.dev;
            isCompress = !program.nocompress;

            const opt = {
                compress: isCompress,
                dev : isDevelop,
                noMap: !!program.nomap,
                config: program.c || program.config || null,
                done: (list) => {
                    const diff = list[0];
                    const miss = list[1];
                    let i;
                    if (diff) {
                        for(i = 0; i < diff.length; i++) {
                            console.log(`    \x1b[36mdiff:\x1b[0m ${diff[i]}`);
                        }
                    }
                    if (miss) {
                        for(i = 0; i < miss.length; i++) {
                            console.log(`    \x1b[31mmiss:\x1b[0m ${miss[i]}`);
                        }
                    }
                }
            };
            checkDirDiff(dir, opt);
        });
    program.parse(process.argv);

    if (process.argv.length < 3) {
        program.help();
        return;
    }
}

function buildDir(fromDir, toDir, opt = {}) {
    fs.readdir(fromDir, (err, files) => {
        if (err) {
            console.log(err);
            return;
        }
        files.forEach((tmp) => {
            if (tmp[0] === '_' || tmp[0] === '.')return;
            const pathFrom = fromDir + tmp;
            const pathTo = toDir + tmp;
            if (!fs.existsSync(toDir)) {
                // 创建目录
                fs.mkdirSync(toDir, 0o755);
            }
            fs.lstat(pathFrom, (err, stat) => {
                if (stat.isDirectory()) {
                    buildDir(pathFrom + '/', pathTo + '/', opt);
                }
                else {
                    const pathToExt = getOutExtFileName(pathTo);
                    if (opt.onlyMissFile && fs.existsSync(pathToExt)) {
                        // 只更新遗漏的文件
                        return;
                    }
                    if (isDevelop)console.log(`    load ${pathFrom.substr(BASE_DIR.length)}`);
                    buildFile(pathFrom, pathToExt, opt);
                }
            });
        });
    });
}

function buildFile(from, to, opt = {}) {
    const ext = path.extname(from);
    switch (ext) {
        case '.js':
            buildJsFile(from, to, opt);
            break;

        case '.vue':
        case '.tpl':
            buildVueFile(from, to, opt);
            break;

        case '.i18n':
        case '.yml':
        case '.yaml':
            buildYamlFile(from, to, opt);
            break;

        case '.css':
        case '.scss':
        case '.sass':
            buildScssFile(from, to, opt);
            break;

        default:
            console.log("    ignore: " + from.substr(BASE_DIR.length));
            break;
    }
}

function getProjectConfig() {
    try {
        const content = fs.existsSync(projectFile) ? fs.readFileSync(projectFile) : '[]';
        list = JSON.parse(content);
        return list;
    }
    catch (e) {
        console.log(e);
        return [];
    }
}

function getBindProject() {
    let found = null;
    getProjectConfig().forEach((item) => {
        if (item.bind) {
            found = item;
        }
    });
    return found;
}

/**
 * 部署一个目录到服务器
 * @param dir
 * @param opt
 */
function deployDir(dir, opt) {
    const oldDone = opt.done;
    const oldError = opt.error;
    const project = getBindProject();
    if (!project) {
        console.log('没有绑定项目，请先绑定');
        return false;
    }
    console.log(`    App: ${project.appName}, Server: ${project.assetsOrigin}`);
    opt = Object.assign(opt, project);

    optOriginCheck(opt);

    opt.done = (list) => {
        const diff = list[0],
            miss = list[1];
        console.log(`    Found ${diff.length} diff file(s), ${miss.length} miss file(s).`);
        if (diff.length > 0) {
            for (let i = 0; i < diff.length; i++) {
                assetsUpdateJob(diff[i], opt, oldDone, oldError);
            }
        }
        if (opt.clean && miss.length > 0) {
            for (let i = 0; i < miss.length; i++) {
                assetsForDelete(miss[i], opt, oldDone, oldError);
            }
        }
    };

    checkDirDiff(dir, opt);
}

let jobDoing = 0;
const jobList = [];
const addHttpJob = (myJob) => {
    if (jobDoing >= 10) {
        jobList.push(myJob);
    }
    else {
        jobDoing++;
        httpPost.apply(this, myJob);
    }
};
const postDone = () => {
    jobDoing--;
    if (jobDoing === 0) {
        console.log('    job done');
    }
    else {
        const myJob = jobList.shift();
        if (myJob) addHttpJob(myJob);
    }
};

function assetsForUpdate(file, project, done, error) {
    let myOpt = {
        done: () => {
            console.log(`    \x1b[32mUpdate done: ${file}\x1b[0m`);
            postDone();
            if (done)done(file);
        },
        error: () => {
            console.log(`    \x1b[31mUpdate fail: ${file}\x1b[0m`);
            postDone();
            if (error)error(file);
        }
    };
    const content = fs.readFileSync(SRC_DIR + file);
    const time    = parseInt(new Date().getTime() / 1000);
    const hash    = md5(content);
    const sign    = md5(`${time}.${file}.${hash}.${project.assetsToken}.${project.adminAccount}`);
    const url     = `${project.assetsOrigin}/up/${project.appName}/${file}?time=${time}&sign=${sign}&user=${project.adminAccount}&hash=${hash}`;
    addHttpJob([url, content, myOpt]);
}

function assetsForDelete(file, conf, done, error) {
    let myOpt = {
        done: () => {
            console.log(`    \x1b[32mDelete done: ${file}\x1b[0m`);
            postDone();
            if (done)done(file);
        },
        error: () => {
            console.log(`    \x1b[31mDelete fail ${file}\x1b[0m`);
            postDone();
            if (error)error(file);
        }
    };
    const time = parseInt(new Date().getTime() / 1000);
    const sign = md5(`${time}.${file}.${conf.assetsToken}.${conf.adminAccount}`);
    const url  = `${conf.assetsOrigin}/rm/${conf.appName}/${file}?time=${time}&user=${conf.adminAccount}&sign=${sign}`;
    addHttpJob([url, '', myOpt]);
}

function assetsForDownload(file, conf, done, error) {
    let myOpt = {
        getContent: true,
        done: (content) => {
            postDone();
            if (false === content) {
                // 服务器文件不存在
                console.log(`    \x1b[32mDownload done (not found): ${file}\x1b[0m`);
                if (error)error('File not found on server: ' + file);
                return;
            }
            console.log(`    \x1b[32mDownload done: ${file}\x1b[0m`);

            // 写文件
            const filePath = SRC_DIR + file;
            const outDir = path.dirname(filePath);
            if (!fs.existsSync(outDir)) {
                // 创建目录
                mkDir(outDir);
            }
            fs.writeFileSync(filePath, content);

            if (done)done(file);
        },
        error: () => {
            console.log(`    \x1b[31mDownload fail ${file}\x1b[0m`);
            postDone();
            if (error)error(file);
        }
    };
    const time = parseInt(new Date().getTime() / 1000);
    const sign = md5(`${time}.${file}.${conf.assetsToken}.${conf.adminAccount}`);
    const url  = `${conf.assetsOrigin}/down/${conf.appName}/${file}?time=${time}&user=${conf.adminAccount}&sign=${sign}`;
    addHttpJob([url, '', myOpt]);
}

/**
 * 检查服务器目录文件差异
 * @param dir
 * @param opt
 */
function checkDirDiff(dir, opt) {
    if (dir)dir = dir.trim().replace(/[\/|\\]+$/, '').replace(/^[\/|\\]+/, '');
    let from = SRC_DIR + (dir ? dir : ''), list;
    if (!fs.existsSync(from)) {
        list = [];
    }
    else if (fs.lstatSync(from).isDirectory()) {
        if (dir) {
            from += '/';
        }
        list = listDirFiles(from);
    }
    else {
        list = [from];
    }

    const fileHash = {};
    for (let i = 0; i < list.length; i++) {
        let ext = path.extname(list[i]);
        switch (ext) {
            case '.vue':
            case '.yml':
            case '.js':
                fileHash[list[i].substr(SRC_DIR.length)] = fileMd5(list[i]);
                break;
        }
    }

    const project = getBindProject();
    if (!project) {
        console.log('没有绑定项目，请先绑定');
        return false;
    }
    console.log(`    App: ${project.appName}, Server: ${project.assetsOrigin}`);
    opt = Object.assign(opt, project);

    optOriginCheck(opt);

    const listStr = JSON.stringify(fileHash);
    const time = parseInt(new Date().getTime() / 1000);
    const sign = md5(`${time}.${listStr}.${opt.assetsToken}.${opt.adminAccount}`);
    const url  = `${opt.assetsOrigin}/check/${opt.appName}?time=${time}&user=${opt.adminAccount}&sign=${sign}`;
    const postData = require('querystring').stringify({list: listStr});

    httpPost(url, postData, opt);
}

function httpPost(url, postData, opt) {
    const options   = require('url').parse(url);
    options.method  = 'POST';
    options.headers = {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Content-Length': Buffer.byteLength(postData)
    };

    const req = require(options.protocol === 'https:' ? 'https' : 'http').request(options, (res) => {
        res.setEncoding('utf8');
        let data = '';
        res.on('data', (chunk) => {
            data += chunk;
        });
        res.on('end', () => {
            try {
                if (res.statusCode === 404) {
                    if (opt.error) opt.error(new Error('Api not found'));
                    return;
                }

                if (opt.getContent) {
                    if (opt.done) {
                        if (res.statusCode === 201) {
                            opt.done(false);
                        }
                        else {
                            opt.done(data);
                        }
                    }
                    return;
                }
                const rs = JSON.parse(data);
                if (rs) {
                    if (rs.status === 'error') {
                        if (opt.error) opt.error(rs.msg);
                        return null;
                    } else {
                        if (opt.done) opt.done(rs.list);
                    }
                } else {
                    const err = `解析服务器返回失败: ${rs.status}`;
                    if (opt.error) opt.error(err);
                }
            }
            catch (e) {
                console.log(e);
                if (opt.error) opt.error(e);
            }
        });
    });
    req.on('error', (e) => {
        console.error(`problem with request: ${e.message}`);
        if (opt.error)opt.error(e);
    });

    req.write(postData);
    req.end();
}

function optOriginCheck(opt) {
    if (opt.assetsOrigin) {
        opt.assetsOrigin = opt.assetsOrigin.replace(/[\/]+$/, '');  // 将结尾的/移除
    }
    else {
        opt.assetsOrigin = opt.dev ? 'https://dev-assets.xdapp.com' : 'https://assets.xdapp.com';
    }
}

function watchProject(opt) {
    let tick;
    const watch = require('./ToolsWatchDir');
    const handle = function (err, lists) {
        if (err) {
            console.error(err);
            if (opt.error)opt.error(err);
            return;
        }
        lists.forEach((item) => {
            if (!item)return;
            let file = item.file,
                out = getAssetsOutFileName(file),
                fileName = path.basename(file)
            ;
            const relativeFile = relativePath(file);
            const l = fileName[fileName.length-1];
            if (fileName[0] === '.' || l === '~' || l === '_' || relativeFile.indexOf('/.') !== -1) {
                // 忽略这些文件, vim 编辑会产生 ~ _ 结尾的文件
                return;
            }
            if (relativeFile.indexOf('/_') !== -1) {
                // 下划线开头的文件或文件夹
                const split = relativeFile.split('/_');
                const parentFile  = BASE_DIR + split[0] + '/' + split[1].split('/')[0] + path.extname(file);
                if (fs.existsSync(parentFile)) {
                    // 更新父文件
                    item.type = 'change';
                    item.file = file = parentFile;
                    delete item.isDir;
                    out = getAssetsOutFileName(file);
                }
                else {
                    // 忽略文件
                    return;
                }
            }

            switch (item.type) {
                case 'change':
                case 'add':
                    const myOpt = Object.assign({
                        compress: isCompress,
                        dev: isDevelop,
                        noMap: opt.noMap,
                    }, opt, {
                        done: (result) => {
                            setAssetFileHash(result.out, md5(result.content), true);
                            if (isAssetFile(result.out)) {
                                if (tick) {
                                    clearTimeout(tick);
                                    tick = null;
                                }
                                tick = setTimeout(saveAssetHashFile, 200);
                            }
                            if (opt.done)opt.done(Object.assign({}, item, result));
                        }
                    });
                    if (item.isDir) {
                        // 增加了一个目录
                        buildDir(file + '/', out + '/', myOpt);
                    }
                    else {
                        const outDir = path.dirname(out);
                        if (!fs.existsSync(outDir)) {
                            // 创建目录
                            mkDir(outDir);
                        }
                        buildFile(file, out, myOpt);
                    }
                    break;
                case 'delete':
                    removeFile(file, out);
                    if (opt.done)opt.done(Object.assign({}, item, {out: out}));
                    break;
            }
        });
    };

    const hashList = watch.getFileHash();
    const noFoundFiles = [];
    for (let k in assetsHash) {
        let path = `${SRC_DIR}${k}`.replace(/\.vue\.js$/, '.vue').replace(/\.json$/, '.yml').replace(/\.css$/, '.scss');
        if (fs.existsSync(path)) {
            hashList[path] = assetsHash[k];
        }
        else {
            noFoundFiles.push(k);
        }
    }
    if (noFoundFiles.length) {
        // 清理数据
        noFoundFiles.forEach((path) => {
            delete assetsHash[path];
        });
        saveAssetHashFile();
    }

    watch(SRC_DIR, handle, {notLoadHash: true});

    if (isDevelop) {
        console.log(`    watch directory ${SRC_DIR}`)
    }
}

function saveAssetHashFile() {
    assetsHashTime = new Date().getTime();
    assetsHash = ksortRecursive(assetsHash);
    fs.writeFileSync(HASH_FILE, JSON.stringify(assetsHash, null, 2).replace(/\n[ ]+/g, '\n'));
    if (isDevelop) {
        console.log(`    update hash: ${HASH_FILE.substr(BASE_DIR.length)}`);
    }
}

function isAssetFile(outFile) {
    return outFile.substr(0, OUT_DIR.length) === OUT_DIR;
}

function setAssetFileHash(outFile, hash, noSave = false) {
    const uri = outFile.substr(OUT_DIR.length);
    if (typeof hash === 'string') {
        // 使用短hash
        hash = hash.substr(0, 7);
    }
    if (assetsHash[uri] !== hash) {
        if (!hash) {
            delete assetsHash[uri];
        }
        else {
            assetsHash[uri] = hash;
        }

        if (!noSave)saveAssetHashFile();
    }
}

function buildVueFile(from, out, opt) {
    fs.readFile(from, {encoding: 'utf-8'}, (err, content) => {
        if (err) {
            console.error(err);
            if (opt.error) opt.error(err);
            return;
        }
        const start = new Date().getTime();

        const allDone = function(rs) {
            fs.writeFile(out, rs.code, (err) => {
                if (err) {
                    console.log(`    \x1b[31merror: ${out}\x1b[0m`);
                    console.error(err);
                    if (opt.error)opt.error(err);
                    return;
                }
                // 写入map内容
                if (!opt.noMap && rs.map)fs.writeFile(`${out}.map`, rs.map, (err) => {
                    if (err) {
                        console.log(`    \x1b[31merror: ${out}.map\x1b[0m`);
                        console.error(err);
                        return;
                    }
                    if (opt.dev) {
                        console.log(`    \x1b[34mwrite ${relativePath(out)}.map\x1b[0m`);
                    }
                });
                if (opt.done)opt.done({
                    file: from,
                    out: out,
                    content: content,
                    contentOut: rs.code
                });

                console.log(`    \x1b[32mwrite ${relativePath(out)}, time: ${new Date().getTime() - start}ms\x1b[0m`);
            });
        };

        const subContents = readSubFiles(from);
        if (subContents.length) {
            let doneNum = 0;
            let code = '';
            const jobNum = subContents.length + 1;
            const done = function(myRs) {
                doneNum++;
                code += "\n" + myRs.code;
                if (doneNum === jobNum) {
                    // 全部完成
                    allDone({
                        code: code,
                    });
                }
            };
            // 编译主文件
            buildVueContent(from, content, done, opt);

            // 编译子文件
            subContents.forEach((item) => {
                content = item.content + '\n' + content;
                buildVueContent(item.file, item.content, done, Object.assign({}, opt, {includeModuleName: true}));
            });
        }
        else {
            buildVueContent(from, content, allDone, opt)
        }
    });
}

function buildVueContent(from, content, done, opt) {
    // 解析VUE组件
    compilerVue.setSassOption('outputStyle', 'compact');
    compilerVue.compile(content, from.substr(BASE_DIR.length), (err, contentVue) => {
        if (err) {
            console.log(`    \x1b[31merror: ${from}\x1b[0m`);
            console.error(err);
            if (opt.error)opt.error(err);
            return;
        }
        const rs = buildJsContent(contentVue, {
            compress: opt.compress,
            noMap: opt.noMap,
            fileName: path.basename(from) + '.js',
            moduleName: getModuleName(from),
            includeModuleName: opt.includeModuleName,
        });
        if (rs.error) {
            console.log(`    \x1b[31merror: ${from}\x1b[0m`);
            console.error(rs.error);
            if (opt.error)opt.error(rs.error);
            return;
        }
        done(rs);
    });
}

function buildScssFile(from, out, opt) {
    fs.readFile(from, {encoding: 'utf-8'}, (err, content) => {
        const start = new Date().getTime();
        let opts = {
            file: path.basename(from),
            data: content,
            outputStyle: opt.compress ? 'compressed' : 'compact',
            includePaths: [
                `${SRC_DIR}css`
            ],
        };
        if (!opt.noMap) {
            opts.sourceMap = `${path.basename(out)}.map`;
            opts.sourceMapContents = true;
        }
        sass.render(opts, (err, result) => {
            if (err) {
                console.log(`    \x1b[31merror ${from}\x1b[0m`);
                console.error(err);
                if (opt.error)opt.error(err);
                return;
            }
            fs.writeFile(out, result.css, function(err) {
                if (err) {
                    console.log(`    \x1b[31merror ${out}\x1b[0m`);
                    console.error(err);
                    if (opt.error)opt.error(err);
                    return;
                }
                if (!opt.noMap && result.map) {
                    fs.writeFile(`${out}.map`, result.map, function (err) {
                        if (err) {
                            console.log(`    \x1b[31merror: ${relativePath(out)}.map\x1b[0m`);
                            console.error(err);
                            return;
                        }
                        if (opt.dev) {
                            console.log(`    \x1b[34mwrite ${relativePath(out)}.map\x1b[0m`);
                        }
                    });
                }
                if (opt.done)opt.done({
                    file: from,
                    out: out,
                    content: content,
                    contentOut: result.css
                });
                console.log(`    \x1b[32mwrite ${relativePath(out)}, time: ${new Date().getTime() - start}ms\x1b[0m`);
            });
        });
    });
}

function buildYamlFile(from, out, opt = {}) {
    fs.readFile(from, {encoding: 'utf-8'}, (err, content) => {
        if (err) {
            console.error(err);
            if (opt.error)opt.error(err);
            return;
        }
        try {
            const start = new Date().getTime();
            let data = YAML.parse(content);
            data = ksortRecursive(data);
            let str = JSON.stringify(data, null, 2);
            if (opt.compress)str = str.replace(/\n[ ]+/g, '\n');
            fs.writeFile(out, str, (err) => {
                if (err) {
                    console.log(`    \x1b[31merror ${out}\x1b[0m`);
                    console.error(err);
                    if (opt.error)opt.error(err);
                    return;
                }
                if (opt.done)opt.done({
                    file: from,
                    out: out,
                    content: content,
                    contentOut: str,
                });
                console.log(`    \x1b[32mwrite ${relativePath(out)}, time: ${new Date().getTime() - start}ms\x1b[0m`);
            });
        }
        catch (err) {
            console.log(`    \x1b[31merror ${from}\x1b[0m`);
            console.error(err);
        }
    });
}

function buildJsFile(from, out, opt = {}) {
    fs.readFile(from, {encoding: 'utf-8'}, (err, content) => {
        if (err) {
            console.log(`    \x1b[31merror ${from}\x1b[0m`);
            console.error(err);
            if (opt.error)opt.error(err);
            return;
        }
        const start = new Date().getTime();
        const rs = content.length ? buildJsContent(content, Object.assign({}, opt, {
            fileName: path.basename(from),
            moduleName: getModuleName(from),
        })) : {
            code: '',
        };
        if (rs.error) {
            console.log(`    \x1b[31merror ${from}\x1b[0m`);
            console.error(rs.error);
            if (opt.error)opt.error(rs.error);
            return;
        }

        // 检查是否有子文件夹
        const subContents = readSubFiles(from);
        if (subContents.length)subContents.forEach((item) => {
            const myRs = buildJsContent(item.content, Object.assign({}, opt, {
                fileName: path.basename(item.file),
                moduleName: item.moduleName,
                includeModuleName: true,
            }));
            rs.code = myRs.code + "\n" + rs.code;
        });

        fs.writeFile(out, rs.code, (err) => {
            if (err) {
                console.log(`    \x1b[31merror ${out}\x1b[0m`);
                console.error(err);
                if (opt.error)opt.error(err);
                return;
            }
            // 写入map内容
            if (!opt.noMap && rs.map)fs.writeFile(`${out}.map`, rs.map, (err) => {
                if (err) {
                    console.log(`    \x1b[31merror: ${out}.map\x1b[0m`);
                    console.error(err);
                    return;
                }
                if (opt.dev) {
                    console.log(`    \x1b[34mwrite ${relativePath(out)}.map\x1b[0m`);
                }
            });
            if (opt.done)opt.done({
                file: from,
                out: out,
                content: content,
                contentOut: rs.code
            });
            console.log(`    \x1b[32mwrite ${relativePath(out)}, time: ${new Date().getTime() - start}ms\x1b[0m`);
        });
    });
}

function readSubFiles(from) {
    const ext = path.extname(from);
    const fileName = path.basename(from);
    const subDir = path.dirname(from) + '/_' + fileName.substr(0, fileName.length - ext.length);
    const rs = [];
    if (fs.existsSync(subDir)) {
        const list = listDirFiles(subDir);
        // const idPrefix = subDir.substr(BASE_DIR.length + 4) + '/';
        if (list.length > 0) list.forEach((item) => {
            const myExt = path.extname(item);
            if (myExt !== ext) {
                // js vue 文件可以相互载入
                if ((ext === '.js' || ext === '.vue') && (myExt === '.js' || myExt === '.vue')) {} else {
                    return;
                }
            }
            let moduleName = item.substr(BASE_DIR.length + 4);
            if (ext === '.js') moduleName = moduleName.substr(0, moduleName.length - 3);
            rs.push({
                file: item,
                moduleName: moduleName,
                content: fs.readFileSync(item, {encoding: 'utf-8'}),
            });
        });
    }
    return rs;
}

function removeFile(file, out = null) {
    out = out || getAssetsOutFileName(file);
    const exist = fs.existsSync(out);
    if (exist && fs.lstatSync(out).isDirectory()) {
        // 移除了一个文件夹
        const list = rmDir(out);
        if (list) {
            list.forEach((out) => {
                setAssetFileHash(out, undefined, true);
            });
            saveAssetHashFile();
        }
    }
    else {
        if (exist) {
            fs.unlinkSync(out);
        }
        if (fs.existsSync(out + '.map')) {
            fs.unlinkSync(out + '.map');
        }
        try {
            const dir = path.dirname(out);
            const lists = fs.readdirSync(dir);
            if (lists.length === 0) {
                // 目录下没文件了
                fs.rmdirSync(dir);
            }
        }
        catch (e) {
            console.log(e);
        }
    }
    console.log(`    \x1b[32mremove ${out.substr(BASE_DIR.length)}\x1b[0m`);

    if (isAssetFile(out)) {
        setAssetFileHash(out, undefined);
    }
}

function getAssetsOutFileName(srcFile) {
    const dir = srcFile.substr(SRC_DIR.length),
        out = OUT_DIR + dir
    ;
    return getOutExtFileName(out);
}

function getOutExtFileName(out) {
    const ext = path.extname(out);
    switch (ext) {
        case '.i18n':
        case '.yml':
        case '.yaml':
            return out.replace(/\.(i18n|yaml|yml)$/i, '.json');

        case '.scss':
        case '.sass':
            return out.replace(/\.(scss|sass)$/i, '.css');

        case '.vue':
        case '.page':
        case '.tpl':
            return `${out}.js`;
    }
    return out
}

function minifyJs(content, fileName, noMap = false) {
    const code = {};
    code[fileName] = content;
    const opts = {};
    if (!noMap) {
        opts.sourceMap = {
            includeSources: true,
            filename: fileName,
            url: `./${fileName}.map`
        };
    }
    return UglifyJS.minify(code, opts);
}

function buildJsContent(content, opt = {}) {
    if (content.indexOf('export ') !== -1 || content.indexOf('import ') !== -1) {
        try {
            // 使用 typescript 处理模块编译
            let rsTs = compileTypescript(content, opt.moduleName, opt.includeModuleName);
            if (opt.compress) {
                // 处理压缩
                return minifyJs(rsTs.outputText, opt.fileName, opt.noMap);
            }
            else {
                // 不需要压缩
                return {
                    code: rsTs.outputText,
                    map: '',
                };
            }
        }
        catch (err) {
            return {
                error : err,
            }
        }
    }
    else if (opt.compress) {
        // 处理压缩
        return minifyJs(content, opt.fileName, opt.noMap);
    }
    else {
        return {
            code: content,
            map: '',
        };
    }
}

let typeScript;
function compileTypescript(content, moduleName, includeModuleName = false) {
    // {outputText: '...', diagnostics: [], sourceMapText: '...'}
    if (!typeScript)typeScript = require('typescript');

    // 处理转换相对目录以及js后缀
    const match = content.match(/import .* from .*/gi);
    if (moduleName && match && match.length)match.forEach((item) => {
        const m = item.match(/^(import.*from[ ]+['"])([^'"]+)(['"].*)$/i);
        if (!m)return;
        const uri = m[2];
        const uriArr = uri.split('/');
        if (uriArr[0] !== '.' && uriArr[0] !== '..') {
            // 无需处理相对目录
            if (path.extname(uri) === '.js') {
                // 移除 .js 后缀
                content = content.replace(m[0], m[1] + uri.substr(0, uri.length - 3) + m[3]);
            }
            return;
        }

        const idArr = path.dirname(moduleName).split('/');
        while (true) {
            if (uriArr[0] === '.') {
                uriArr.shift();
            }
            else if (uriArr[0] === '..') {
                uriArr.shift();
                idArr.pop();
            }
            else {
                break;
            }
        }
        let newUri = idArr.concat(uriArr).join('/');
        if (path.extname(newUri) === '.js') {
            newUri = newUri.substr(0, newUri.length - 3);
        }
        content = content.replace(m[0], m[1] + newUri + m[3]);
    });

    let rs = typeScript.transpileModule('import * as module from "module";\n' + content, {
        // moduleName: includeModuleName ? moduleName : undefined,
        compilerOptions: {
            module: typeScript.ModuleKind.AMD,
            jsx: typeScript.JsxEmit.React,
            target: typeScript.ScriptTarget.ES5,  // 定义输出语言类型
            sourceMap: false,
            noEmitHelpers: true,        // 不输出辅助代码
        }
    });

    if (includeModuleName) {
        // 由于发现 moduleName 和加入的 import * as module from "module"; 有冲突，所以另外替换进入
        rs.outputText = rs.outputText.replace(/^define\(\["require"/, 'define("'+ moduleName +'", ["require"');
    }

    return rs;
}

function md5(str) {
    return crypto.createHash('md5').update(str).digest('hex');
}

function fileMd5(file) {
    return md5(fs.readFileSync(file));
}

function ksortRecursive(obj) {
    const isArr = obj instanceof Array;
    if (isArr) {
        obj.sort();
        obj.forEach((item, index) => {
            if (item instanceof Object) {
                obj[index] = ksortRecursive(obj);
            }
        });
        return;
    }
    let keys = Object.keys(obj);
    let len = keys.length;
    let rs = {};
    let i;
    keys.sort();
    for (i = 0; i < len; i++) {
        let key = keys[i];
        if(obj[key] instanceof Object) {
            rs[key] = ksortRecursive(obj[key]);
        }
        else {
            rs[key] = obj[key];
        }
    }
    return rs;
}

function mkDir(dir) {
    let rs = true;
    dir.substr(BASE_DIR.length).split('/').reduce((currentPath, folder) => {
        currentPath += folder + '/';
        let currentFullPath = BASE_DIR + currentPath;
        if (!fs.existsSync(currentFullPath)) {
            rs = fs.mkdirSync(currentFullPath, 0o755);
        }
        return currentPath;
    }, '');
    return rs;
}

function rmDir(dir) {
    const list = [];
    dir = dir.replace(/[\/|\\]+$/, '');
    fs.readdirSync(dir).forEach((fileName) => {
        const path = dir + '/' + fileName;
        if (fs.lstatSync(path).isDirectory()) {
            list.concat(rmDir(path));
        }
        else {
            fs.unlinkSync(path);
            list.push(path);
        }
    });
    fs.rmdirSync(dir);
    return list;
}

function cleanDir(dir) {
    dir = dir.replace(/[\/|\\]+$/, '');
    fs.readdirSync(dir).forEach((fileName) => {
        const path = dir + '/' + fileName;
        if (fs.lstatSync(path).isDirectory()) {
            rmDir(path);
        }
        else {
            fs.unlinkSync(path);
        }
    });
}

function listDirFiles(dir) {
    let rs = [];
    dir = dir.replace(/[\/|\\]+$/, '');
    fs.readdirSync(dir).forEach((fileName) => {
        if (fileName[0] === '.')return;
        const path = dir + '/' + fileName;
        if (fs.lstatSync(path).isDirectory()) {
            rs = rs.concat(listDirFiles(path));
        }
        else {
            rs.push(path);
        }
    });
    return rs;
}

function relativePath(file) {
    return file.substr(BASE_DIR.length);
}

// 获取用于requirejs的id
function getModuleName(srcFile) {
    return srcFile.substr(SRC_DIR.length);
}